<!DOCTYPE html>
<html>
  <head>
    <title>javascript공부</title>
    <link rel="stylesheet" href="button.css">
  </head>
  <body>
    <!-- 공부한 내용 -->
    <h1 class = 'chapter'>javascript</h1> 
    <ol>
      <h1><li class = 'theme'>객체(Object)</li></h><br>
      <p>
        <h2>선언방법</h2>
        <h3>let object = { &emsp;propertyName : propertyValue,&emsp;functionName : function(parameter){ 메소드 내용 } }</h3><br>
      <ul>
        <h3 class = 'subtheme'>
        propertyName을 ‘ ‘ 사이에 넣지않았을 때 주의할 사항들
        </h3>
        <li>
          propertyName은 문자열이기 때문에 ' ‘사이에 넣어야하지만 자바스크립트에서 자동 형변환
        </li><br>
        <li>
          속성값으로 모든 자료형을 넣을 수 있음
        </li><br>
        <li>
          첫글자는 무조건 문자, _ , $ 중 하나로 해야함
        </li><br>
        <li>
          띄어쓰기는 하면 안됨
        </li><br>
        <li>
          하이픈( - ) 금지
        </li>
      </ul><br>
      <ul>
        <h3 class = 'subtheme'>객체의 속성에 접근하는 법</h3>
        <li>
          <b>object.propertyName</b> = propertyName이 ' '안에 들어있지않을 때
        </li><br>
        <li>
          <b>object[ propertyName ]</b> = propertyName이 ' '안에 들어있을 때 
        </li><br>
        <li>
          하이픈( - ) 금지
        </li>
      </ul><br>
      <ul>
        <h3 class = 'subtheme'>객체의 속성 추가, 삭제</h3>
        <li>추가 = <b>object . propertyName(추가할 속성)</b> = propertyValue(추가할 속성 값) </li><br>
        <li>삭제 = <b>delete object . propertyName(삭제할 속성)</b> </li><br>
      </ul>
      <ul>
        <h3 class = 'subtheme'>Date 객체</h3>
        
      </ul>
      </p>
      <br>
      <h1><li class = 'theme'>배열(Array) / 배열도 객체</li></h><br>
      <p>
      <h3>선언방법</h3>
      let Array = [ element, element2, element3 ]  &nbsp;/&nbsp;  let Array = [ [ element, element2 ],[ element3, element4 ] ]
      <br>
      <br>배열 접근 : Array[ index ]; / Array[ [ index ], [ index ] ]; index는 0부터 시작</li>
      <ul>
        <h3 class = 'subtheme'>배열의 요소 수정, 추가, 삭제</h3>
        <li><b>Array[ index ] = ' ';</b><br>Array안에 존재하는 index의 경우는 수정이 되고 없는 경우는 추가가 됨</li><br>
        <li><b>delete Array[ index ];</b><br>요소의 내용이 삭제되지만 empty 값으로 자리는 남아있음</li><br>
      </ul>
      </p>
      <br>
      <h1><li class = 'theme'>자료형</li></h1><br>
      <p>
        <ol>
        <h3 class = 'subtheme'><li>숫자표기법 ( Number )</li></h3>
          <ul>
            <li>let million = 1000000;</li>
            <br><li>let million = 1e6; / let one = 1000e-3 / 지수 표기법 - e뒤에 숫자만큼 10을 곱함</li>
            <br><li>let binary = 0b11111111 / 255의 2진법 표기법</li>
            <br><li>let octal = 0o377 / 255의 8진법 표기법</li>
            <br><li>let hexadecimal = 0xff / 255의 16진법 표기법</li>
            <br><li>Number로 형변환 시 Number( ) 혹은 앞에 '+' 연산시에는 숫자로 자동형변환 됨</li>
          </ul><br>
        <h3 class = 'subtheme'><li>문자열 ( String )</li></h3>
          <ul>
            <li>문자열이랑 배열을 비슷하게 사용 되지만 배열은 mutable(바뀔 수 있음)이지만 문자열은 immutable(바뀔 수 없음)이다</li>
          </ul><br>
        <h3 class = 'subtheme'><li>참조형 변수 </li></h3>
          <ul>
            <li>객체를 생성 후 객체랑 연결된 주소값이 저장됨</li>
            <br><li>객체의 속성이 변경될 시 객체와 연결된 요소들 또한 모두 바뀌게 됨 </li>
          </ul><br>
        <h3 class = 'subtheme'><li>상수</li></h3>
          <ul>
            <li>
              상수는 재선언이 불가능하기 떄문에 고정된 값을 저장하는데 쓰임
            </li><br>
            <li>
              변하지 않는 변수의 경우는 상수로 선언해주는게 더 좋음 ( 안정적 )
            </li><br>
            <li>
              영어대문자와 스페이스는 _로 표기 ( ex. const ME_YOU_SHE_HE = 'human' )
            </li><br>
            <li>
              상수가 배열이나 객체와 연결시에는 참조변수에 직접적을 변경은 가능하다( 상수를 변경하는게 아니기 때문에)
            </li>
          </ul>
        </ol>
      </p>
      <br>
      <h1><li class = 'theme'>html에서 javascript 사용하는 법</li></h1><br>
       <p>
         <ul>
           <li>html body태그 제일 아래에 &lt;script src = ' index . js '&gt; &lt;/script&gt; 삽입 </li>
         </ul>
         <br>
       </p>
       <br>
      <h1><li class = 'theme'>window 객체</li></h1><br>
      <p>
        <ul>
          <li>
            window 객체는 javascript의 전역객체이다 ( globalObject ) 최고조상객체
          </li>
        </ul>
      </p>
      <br>
      <h1><li class = 'theme'>DOM ( Document Object Model )</li></h1><br>
      <p>
        <ul>
          <li>
            웹브라우저에 나타는 컨텐츠 부분을 웹페이지, 웹문서라고 칭한다
          </li><br>
          <li>
            웹브라우저에 나타는 모든 html 문서를 객체로 표현한 것이 DOM
          </li><br>
          <li>
            document객체가 웹문서의 최상단 객체로 document로 웹페이지의 내부를 얼마든지 수정하고 만들 수 있다
          </li><br>
          <h3 class = 'subtheme'><li>DOM 트리</li></h3>
          <ul>
            <li>부모태그와 자식태그 ( ex. HTML 부모 태그 안에 Head, body 자식 태그 )</li><br>
            <li>전역태그인 document를 부모태그로 밑에 모든 자식태그들을 표시한게 DOM 트리</li><br>
            <li>DOM 트리에서 각 객체를 Node라고 부른다</li><br>
            <li>부모노드 ( parentNode ) 와 자식노드 ( childNode )와 형제노드( 같은 부모노드에 있는 노드들의 관계 )( siblingNode )</li><br>
            <li>노드의 타입은 여러가지인데 html 태그들을 일컫는 노드는 요소 노드( element ), 문자를 일컫는 노드는 텍스트 노드, 주석을 일컫는 commentNode, 문서 전체를 일컫는 documentNode </li><br>
            <li>텍스트 노드는 대부분 요소 노드의 자식 노드이고 자식 노드를 가질 수 없다.</li>
          </ul>

          
        </ul>
      </p><br>
      <h1><li class = 'theme'>javascript로 css 제어</li></h1>
      <p>
        <ul>
          <li>
            element . style . property = ' propertyValue ' = element의 style을 직접적으로 적용
          </li><br>
          <li>
            위에 방법이 많이 쓰이지 않는 이유는 우선순위가 제일 높게 설정이 되는 이유와 같은코드를 여러번 반복하여 작성하여야 되기 떄문에
          </li><br>
          <li>
            해당 style을 가지는 class를 css에서 생성하여 그 class 를 부여하는 방식으로 적용한다. 
          </li> <br>
          <li>
            ( element . className = ' ' / element . classList . add ( ' ' ))
          </li><br>
          <li>
            class 전체를 바꿀 때는 className을 수정할때는 classList를 사용
          </li><br>
          <li>
            css에서 [ 속성이름 ]은 대괄호 안에 있는 속성이름을 가진 태그들을 선택할 수 있고 [ 속성이름="값" ]는 더 구체적으로 태그들을 선택할 수도 있다.
          </li><br>
          <li>
            비표준속성을 사용할 시에는 dataset 프로퍼티를 사용하는데 data- 로 시작되는 속성들은 모두 dataset 객체에 저장이 된다 ( ex. data-status )
          </li>
        </ul>
      </p><br>
      <h1><li class = 'theme'>이벤트와 버튼</li></h1><br>
        <p>
          <ul>
            <li>
              InputVariable . Event = function ( ) { event가 발생했을 때 실행할 내용 };
            </li><br>
            <li>
              event가 발생했을시 특정동작을 하도록 하는 것을 ' eventHandling ' 이라고 한다
            </li><br>
            <li>
              ' eventHandling ' 을 하는 함수를 ' eventHandler '( eventListener ) 라고 한다 
            </li><br>
            <li>
              버튼을 누를경우 onclick Event가 발동되면서 eventHandler 가 작동한다 &nbsp;
              <input type="button" id = 'button'  value = 'click'/>
            </li><br>
            <li>
              eventHandler의 경우 javascript파일 말고 html에 직접 작성도 가능하다 ( 하지만 javascript와 html이 섞여 유지보수가 힘들어질 수 있기 때문에 비추천)
            </li><br>
            <li>
              eventHandler에서 event 자체를 사용 다시 선언하면 그전 eventHandler가 덮여씌여지기 때문에 잘씌여지지 않는다 
            </li><br>
            <li>
              이벤트가 발생할 때마다 event 객체가 생성되고 eventHandler의 첫번째 파라미터로 전달된다.
            </li><br>
            <h3 class = 'subtheme'><li>event 객체가 공통으로 가지고 있는 property</li></h3>
            <p>
              <ul>
                <li>type = 이벤트의 이름</li><br>
                <li>target = 이벤트가 발생한 요소</li><br>
                <li>currentTarget = 이벤트 핸들러가 등록된 요소</li><br>
                <li>timestamp = 이벤트가 발생된 시간(페이지가 로드된 이후부터 지난 밀리초)</li><br>
                <li>bubbles = 버블링 단계인지를 판단하는 값</li><br>
              </ul>
            </p><br>
            <h3 class = 'subtheme'><li>마우스 이벤트 객체가 공통으로 가지고 있는 property</li></h3>
            <p>
              <ul>
                <li>button = 누른 마우스의 버튼 (0: 왼쪽, 1: 가운데(휠), 2: 오른쪽)</li><br>
                <li>clientX, clientY = 마우스 커서의 브라우저 표시 영역에서의 위치</li><br>
                <li>
                  pageX, pageY = 마우스 커서의 문서 영역에서의 위치
                </li><br>
                <li>
                  offsetX, offsetY = 마우스 커서의 이벤트 발생한 요소에서의 위치
                </li><br>
                <li>
                  screenX, screenY = 마우스 커서의 모니터 화면 영역에서의 위치
                </li><br>
                <li>
                  altKey = 이벤트가 발생할 때 alt키를 눌렀는지
                </li><br>
                <li>
                  ctrlKey = 이벤트가 발생할 때 ctrl키를 눌렀는지
                </li><br>
                <li>
                  shiftKey = 이벤트가 발생할 때 shift키를 눌렀는지
                </li><br>
                <li>
                  metaKey = 이벤트가 발생할 때 meta키를 눌렀는지 (window는 window키, mac은 cmd키
                </li>
              </ul>
            </p><br>
            <h3 class = 'subtheme'><li>키보드 이벤트 객체가 공통으로 가지고 있는 property</li></h3>
            <p>
              <ul>
                <li>
                  key	 = 누른 키가 가지고 있는 값
                </li><br>
                <li>
                  code = 누른 키의 물리적인 위치
                </li><br>
                <li>
                  altKey = 이벤트가 발생할 때 alt키를 눌렀는지
                </li><br>
                <li>
                  ctrlKey = 이벤트가 발생할 때 ctrl키를 눌렀는지
                </li><br>
                <li>
                  shiftKey = 이벤트가 발생할 때 shift키를 눌렀는지
                </li><br>
                <li>
                  metaKey = 이벤트가 발생할 때 meta키를 눌렀는지 (window는 window키, mac은 cmd키)
                </li><br>
              </ul>
            </p>
            <h3 class = 'subtheme'><li>이벤트 버블링, 캡처링, 타겟, 위임</li></h3>
            <p>
              <ul>
                <li>
                  이벤트핸들러가 작동시 같은 타입의 이벤트에 한해서 부모요소의 핸들러가 같이 작동하는 경우 ( window 전역객체까지 진행 )
                </li><br>
                <li>
                  버블링이 발생해도 e . target 은 처음에 발생한 target으로 리턴된다 ( 버블링이 발생한 부모요소를 리턴하고 싶을 시에는 currentTarget 프로퍼티를 사용 )
                </li><br>
                <li>
                  버블링을 멈추고 싶을시에는 e . stopPropagation ( )
                </li><br>
                <li>
                  버블링을 멈출시에 부모요소의 eventHandler의 범위에 예외가 생긴다
                </li><br>
                <li>
                  캡처링은 버블링의 반대로 부모요소의 이벤트가 자식요소로 전달되는 단계
                </li><br>
                <li>
                  캡처링을 설정시에는 addEventListener에 세번째 프로퍼티에 true 또는 { capture:true }를 작성하면 된다.
                </li><br>
                <li>
                  이벤트 위임의 경우는 버블링을 사용하여 자식요소에 각각 이벤트핸들러를 할당하는게 아닌 부모요소에 할당하여 모든 자식요소에 할당하는 법( target이 버블링되어도 발생된 자식요소가 나오기 때문에 가능 )
                </li><br>
                <li>
                  위임할때 if 문으로 정확한 위치를 정해주지 않으면 부모요소에 이벤트가 발생할경우 모든 자식요소에 이벤트핸들러가 작동된다.
                </li>
              

              </ul>
            </p>
            <h3 class = 'subtheme'></h3>
          </ul>
        </p>
    </ol>
    <br><br><!-- 메소드들 -->
    <h1 class = 'chapter'>Method리스트</h1>
    
    <ul>
      <li>
        typeof element / element의 자료형을 나타냄
      </li><br>
    </ul>
      <h2 class = 'theme'>Date 메소드</h2>
      <ul>
        <li>사용시 let myDate = new Date(); 객체 선언 후 사용</li><br>
        <li>현재 날짜 + 시간을 보려면 console . log ( myDate ) / myDate . toLocaleString ( )<br>
          <p>
            <ul>
              <li>myDate . getFullyear = 년도</li><br>
              <li>myDate . getMonth = 월</li><br>
              <li>myDate . getDate = 일</li><br>
              <li>myDate . getDay = 요일 ( 일요일부터 0 )</li><br>
              <li>myDate . getHours = 시</li><br>
              <li>myDate . getMinutes = 분</li><br>
              <li>myDate . getSeconds = 초</li><br>
              <li>myDate . getMilliseconds = 밀리초</li><br>
              <li>get 대신 set을 사용하면 수정</li>
            </ul>
          </p>
        </li>
      </ul>
      <h2 class = 'theme'>Object 메소드</h2>
      <ul>
        <li>
          propertyName in object = object객체안에 propertyName의 속성의 있는지 확인
        </li><br>
        <li>
        for ( let property in object ) { }; = 객체의 속성갯수만큼 반복되고 property에는 객체의 속성이름이 할당됨 
        </li><br>
        <li>
          for ( let property in object ) { console.log(property) }; = object의 propertyName을 모두 출력
        </li><br>
        <li>
          for ( let property in object ) { console.log(object.property) }; = object의 propertyValue를 모두 출력
        </li><br>
        <li>
          object . assign ( target, source ); = target 객체에 source를 복사하여 붙여넣는다
        </li>
      </ul>
      <h2 class = 'theme'>Array 메소드</h2>
      <ul>
        <li>
          Array . isArray ( parameter ) = parameter가 배열일 경우 true, 아니면 false를 리턴
        </li><br>
        <li>
          [ Object / Array / String ] . length
          <br>객체의 속성의 개수 / 배열의 요소의 개수 / 문자열의 길이
        </li><br>
        <li>
          delete [ object.propertyName / Array [ index ] ]
          <br>객체의 속성 삭제 /  배열의 요소 삭제(삭제된 곳은 empty로 자리가 남아있음)
        </li><br>
        <li>
          Array . splice( index ) 를 사용하면 자리도 남지않게 삭제 가능
          <br>.splice( indexNumber, deletecount, item)
          <br>
          <br>Array . splice( 3 ) = Array[ 3 ]부터 뒤에 모든 요소를 삭제
          <br>Array . splice( 3, 2 ) = Array [ 3 ]부터 2개의 요소를 삭제
          <br>Array . splice( 3, 2, 'add') = Array [ 3 ]부터 2개의 요소를 삭제 후 그자리에 'add' 추가
        </li><br>
        <li>
          Array . shift( 값 ) / Array . unshift( 값 ) = 배열의 첫 요소를 삭제, 추가
        </li><br>
        <li>
          Array . pop( 값 ) / Array . push( 값 ) = 배열의 마지막 요소를 삭제, 추가
        </li><br>
        <li>
          String / Array . indexOf ( '값' ) = 값이 포함된 문자열, 배열의 index가 리턴 / 값이 없다면 -1 리턴
          <br><br>값이 여러개일 경우 앞에서 첫번째 요소의 index 리턴
          <br>
          <br>String / Array . lastIndexOf ( '값' ) = 값이 포함된 문자열, 배열의 index가 리턴 / 값이 없다면 -1 리턴
          <br><br>  값이 여러개일 경우 뒤에서 첫번째 요소의 index 리턴
        </li><br>
        <li>
          Array . include( '값' ) = 배열에 값이 있으면 true 없으면 false 리턴
        </li><br>
        <li>
          Array . reverse() = 배열의 순서를 반대로
        </li><br>
        <li>
          for ( let element of Array){ }; = Array 요소의 갯수만큼 반복되고 element에 요소들이 차례대로 할당
          <br><br>  for ( let element of Array ){ console.log ( element ) }; = Array의 요소들이 모두 출력됨
          <br><br> String에도 똑같이 사용할 수 있음 
        </li>
      </ul>
      <h2 class = 'theme'> Number, Math 메소드</h2>
      <ul>
        <li>
          Number변수 . toFixed ( ) = parameter값( 1~100 ) 번쨰 소수점까지만 표시된 <b>문자열로</b> 리턴 (반올림)
        </li><br>
        <li> Number변수 . toString ( ) = parameter값 ( 2~36 ) 진수로 변환
        <br><br>Number가 숫자일 때 345 .. toString( parameter ); / ( 345 ) . toString( ); 으로 써야함
        </li><br>
        <li> Math . abs( Number ) = Number의 절대 값 리턴</li><br>
        <li> Math . max( Number ,Number2, Number3, Number4 ) = 파라미터 중 제일 큰 숫자 리턴  / Math . min( )는 반대 </li><br>
        <li>Math . pow ( Number, count ) = Number의 count만큼 거듭제곱을 리턴</li><br>
        <li>Math . sqrt ( Number ) = Number의 제곱근</li><br>
        <li>Math . round ( Number ) = Number의 소숫점 첫쨰 자리에서 반올림한 값을 리턴 / Math . floor() = 버림 / Math . ceil() = 올림</li><br>
        <li>Math . random ( ) = 0 이상 1미만인 소수중 랜덤으로 하나 리턴</li>
      </ul>
      <h2 class = 'theme'> String 메소드</h2>
      <ul>
        <li>String[ Number ] / String . charAt( Number ) = 문자열의 Number 번째 글자</li><br>
        <li>String . toUpperCase() / String . toLowerCase() = 문자열 모두를 대문자로, 소문자로 변환</li><br>
        <li>String . trim() = 문자열 앞, 뒤의 공백을 없애기</li><br>
        <li>String . slice( start, end ) = start부터 end-1 까지의 문자열을 리턴
        <br><br>end값이 없을 경우는 start부터 끝까지 / 둘다 없을 경우는 문자열 전체</li><br>
        <li>let Array = [ element, element2, elemenet3 ];
          <br><br>let Array2 = Array / 객체 주소값이 복사되기에 Array를 수정시 같이 수정 됨
          <br><br>let Array2 = Array . slice( ) / 객체 주소값이 아닌 배열 Array 자체가 복사 됨
        </li>
      </ul>
      <h2 class = 'theme'>Html 조작 메소드</h2>
      <ul>
        <li>document . getElementById( ' idTagName ' ) = id의 이름에 해당되는 첫번째 요소를 리턴 
          <p>
            <ul>
              <li>존재하지 않는 아이디 값을 입력시 null 이 리턴</li><br>
              <li>아이디는 여러개의 요소를 사용할 때는 좋지않아 class 를 사용함</li>
            </ul>
          </p>
        </li>
        <li>
          document . getElementsByClassName( ' className ' ) = class의 이름에 해당되는 모든요소를 HTMLcollection 유사배열로 리턴 
          <p>
            <ul>
              <li>존재하지 않는 클래스값을 찾을 시에는 null이 아닌 빈 HTMLcollection이 출력됨 </li><br>
              <li>유사배열의 경우 배열은 아니지만 ArrayLikeObject [ index ] / ArrayLikeObject . length( ) / for( let element of ArrayLikeObject ) 문은 사용가능</li><br>
              <li>HTMLcollection의 경우 맨위부터 순서대로 배열에 들어가 있음</li><br>
              <li>HTMLcollection 안에 요소가 한개만 있더라도 유사배열로 만들어짐 </li>
            </ul>
          </p>
        </li>
        <li>
          document . getElementsByTagName ( ' tagName ' ) = tag의 이름에 해당되는 모든 요소들을 HTMLcollection 유사배열로 리턴
          <p>
            <ul>
              <li>tagName에 ' * ' 을 넣을 시 모든 태그에 해당 됨</li>
            </ul>
          </p>
        </li>
        <li>
          <h3>document . querySelector ( ' CSSselector ' ) = CSS선택자에 해당되는 요소를 리턴 ( 대체적으로 많이 쓰임 )</h3>
          <p>
            <ul>
              <li> ' . '을 앞에 붙이면 class</li><br>
              <li>' # ' 을 앞에 붙이면 Id</li><br>
              <li>querySelector의 경우는 제일 처음에 있는 요소만 리턴</li><br>
              <li>document . querySelectorAll ( ' CSSselector ' ) = CSS선택자에 해당되는 모든 요소를 NodeList라는 유사배열로 리턴</li>
            </ul>
          </p>
        </li>
        <li></li>
        
      </ul>
      <h2 class = 'theme'>window 객체 메소드</h2>
      <ul>
        <li>
          window 객체는 browser의 모든 내용을 담고 있다
        </li><br>
        <li>
          <a href="https://developer.mozilla.org/ko/docs/Web/API/Window">
          window 객체의 property, function 리스트
          </a>
        </li>
      </ul>
      <h2 class = 'theme'>DOM 객체 메소드</Datag></h2>
      <ul>
        <li>
          console . log ( document ) = html 태그들을 출력한다.
        </li><br>
        <li>
          console . dir ( document ) = document 객체의 property를 출력한다.
        </li><br>
        <li>
          console . log 는 element 의 값을 위주로 출력, console . dir 은 element 의 속성까지 자세히 출력
        </li><br>
        <li>
          log 는 여러개의 값을 지정할 수 있으나 dir은 여러개를 지정하더라도 제일 앞의 한개의 값만 출력
        </li><br>
        <li>
          element . children [ index ] = element의 자식노드들 가진 유사배열 HTMLcollection이 리턴
        </li><br>
        <li>
          element . firstElementChild = 자식노드 중 첫번째, element . lastElementChild = 자식노드 중 마지막
        </li><br>
        <li>
          element . parentElement = element의 부모노드
        </li><br>
        <li>
          element . previousElementSibling = 이전 형제 노드, element . nextElementSibling = 다음 형제 노드
        </li><br>
        <li>
          요소 노드가 아닐 시에는 Element 대신 Node / child의 경우는 firstChild, lastChild 
        </li><br>
        <li>
          element . innerHTML = ' ';  = element 안에 있는 HTML을 리턴하거나 ' '로 바꿈  ( 띄어쓰기나 들여쓰기 등 모든것이 포함 )
        </li><br>
        <li>
          element . innerHTML += ' '; = ' '를 마지막에 추가
        </li><br>
        <li>
          element . outerHTML = ' '; = element를 포함한 HTML을 리턴하거나  ' '로 바꿈 ( element 자체가 바뀌게 됨 )
        </li><br>
        <li>
          element . textContent = ' '; = element 안에 있는 HTML 태그를 제외한 문자들을 리턴하거나 ' '안의 내용으로 바꿈( 특수문자도 텍스트로 출력하기에 태그도 문자로 출력)
        </li><br>
        <li>
          document . createElement ( ' ' ) = ' ' 안에 있는 태그를 가진 요소 노드를 생성
        </li><br>
        <li>
          element( node ) . prepend ( parameter ) = parameter를 element의 첫번째 자식 노드로 넣는다 / node에 parameter를 옮겨서 넣는다
        </li><br>
        <li>
          element( node ) . append ( parameter ) = parameter를 element의 마지막 자식 노드로 넣는다 / node에 parameter를 옮겨서 넣는다
        </li><br>
        <li>
          element( node ) . before ( parameter ) = parameter를 element의 이전 형제 노드로 넣는다 / node에 parameter를 옮겨서 넣는다
        </li><br>
        <li>
          element( node ) . after ( parameter ) = parameter를 element의 다음 형제 노드로 넣는다 / node에 parameter를 옮겨서 넣는다
        </li><br>
        <li>
          parameter에 여러가지 값이 들어갈 시 입력한 순서 그대로 들어간다.
        </li><br>
        <li>
          node . remove ( ); = node를 삭제
        </li><br>
        <li>
          htmlElement . getAttribute ( 'property ') = html요소의 모든 속성에 접근할 수 있다.
        </li><br>
        <li>
          htmlElement . setAttribute ( ' property' , 'propertyValue' ) = 해당 property가 없을 시에는 추가 있을 시에는 수정
        </li><br>
        <li>
          htmlElement . removeAttribute ( ' property ' ) = 해당 property를 삭제 
        </li><br>
        <li>
          element . className = ' ' ; = element의 클래스를 ' '안의 값으로 변경
        </li><br>
        <li>
          element . classList = element의 클래스들을 유사배열로 리턴
        </li> <br>
        <li>
          element . classList . add ( ' ' ) = element의 클래스에 ' '안고 같은 클래스를 추가한다 여러개일 경우 모두 추가됨 ( 중복으로 추가해도 하나만 적용됨 )
        </li><br>
        <li>
          element . classList . remove ( ' ' ) = element의 클래스에 ' '안과 같은 클래스를 삭제한다 여러개일 경우 모두 삭제됨
        </li><br>
        <li>
          element . toggle ( ' ' , boolean ) = 클래스값이 있으면 삭제 없으면 추가 한다 / boolean에 true가 들어가면 추가만 , false가 들어가면 삭제만 한다
        </li><br>

      </ul>
      <h2 class = 'theme'>이벤트 객체 메소드</h2>
      <ul>
        <li>
          element . addEventListner ( ' event ' , ' handler ') 가 제일 많이 쓰인다.  / removeEventListener 의 경우 addEventListener로 추가된 event에 한해서 삭제된다.
         </li><br>
         <li>b
           event . preventDefault ( ) = 이벤트의 기본동작을 막음 
         </li>
      </ul>
    </ul>
    <script src = 'button.js'></script>
  </body>
</html>